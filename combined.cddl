
start = bpsec-cose-asb / AAD-structure /
  primary-block / extension-block /
  MAC_structure / Sig_structure / Enc_structure / COSE_KeySet
        

; Specialize the ASB for this context
bpsec-cose-asb = bpsec-context-use<
  0, ; Context ID TBD-COSE
  $bpsec-cose-param,
  $bpsec-cose-result
>
$ext-data-asb /= bpsec-cose-asb
        

$bpsec-cose-param /= [1, COSE_Key]
$bpsec-cose-param /= [2, COSE_KeySet]
            

$bpsec-cose-param /= [3, additional-protected]
additional-protected = empty_or_serialized_map

$bpsec-cose-param /= [4, additional-unprotected]
additional-unprotected = header_map
            

$bpsec-cose-param /= [5, AAD-scope]
AAD-scope = uint .bits AAD-scope-flags
AAD-scope-flags = &(
    has-primary-ctx: 0,
    has-target-ctx: 1,
    has-security-ctx: 2,
)
            

$bpsec-cose-result /= [16, bstr .cbor COSE_Encrypt0]
$bpsec-cose-result /= [17, bstr .cbor COSE_Mac0]
$bpsec-cose-result /= [18, bstr .cbor COSE_Sign1]
$bpsec-cose-result /= [96, bstr .cbor COSE_Encrypt]
$bpsec-cose-result /= [97, bstr .cbor COSE_Mac]
$bpsec-cose-result /= [98, bstr .cbor COSE_Sign]
          

AAD-structure = [
    ; non-null if has-primary-ctx is set
    primary-ctx:  null / primary-block,
    ; non-null if has-target-ctx is set
    target-ctx:   null / block-metadata,
    ; non-null if has-security-ctx is set
    security-ctx: null / block-metadata,
    ; copy of additional-protected (or default)
    additional-protected
]
; The first three fields of BP "canonical-block-structure"
block-metadata = [
    block-type-code: uint,
    block-number: uint,
    block-control-flags,
]
            
; start = COSE_Messages / COSE_Key / COSE_KeySet / Internal_Types

; This is defined to make the tool quieter:
Internal_Types = Sig_structure / Enc_structure / MAC_structure /
        COSE_KDF_Context

label = int / tstr
values = any

COSE_Messages = COSE_Untagged_Message / COSE_Tagged_Message
      
COSE_Untagged_Message = COSE_Sign / COSE_Sign1 /
    COSE_Encrypt / COSE_Encrypt0 /
    COSE_Mac / COSE_Mac0

COSE_Tagged_Message = COSE_Sign_Tagged / COSE_Sign1_Tagged /
    COSE_Encrypt_Tagged / COSE_Encrypt0_Tagged /
    COSE_Mac_Tagged / COSE_Mac0_Tagged

Headers = (
    protected : empty_or_serialized_map,
    unprotected : header_map
)

header_map = {
    Generic_Headers,
    * label => values
}

empty_or_serialized_map = bstr .cbor header_map / bstr .size 0


Generic_Headers = (
    ? 1 => int / tstr,  ; algorithm identifier
    ? 2 => [+label],    ; criticality
    ? 3 => tstr / int,  ; content type
    ? 4 => bstr,        ; key identifier
    ? 5 => bstr,        ; IV
    ? 6 => bstr,        ; Partial IV
    ? 7 => COSE_Signature / [+COSE_Signature] ; Counter signature
)

COSE_Sign_Tagged = #6.98(COSE_Sign)

COSE_Sign = [
    Headers,
    payload : bstr / nil,
    signatures : [+ COSE_Signature]
]

COSE_Signature =  [
    Headers,      
    signature : bstr
]

COSE_Sign1_Tagged = #6.18(COSE_Sign1)

COSE_Sign1 = [
    Headers,
    payload : bstr / nil,
    signature : bstr
]

Sig_structure = [
    context : "Signature" / "Signature1" / "CounterSignature",
    body_protected : empty_or_serialized_map,
    ? sign_protected : empty_or_serialized_map,
    external_aad : bstr,
    payload : bstr
]

COSE_Encrypt_Tagged = #6.96(COSE_Encrypt)

COSE_Encrypt = [
    Headers,
    ciphertext : bstr / nil,
    recipients : [+COSE_recipient]
]

COSE_recipient = [    
    Headers,
    ciphertext : bstr / nil,
    ? recipients : [+COSE_recipient]
]

COSE_Encrypt0_Tagged = #6.16(COSE_Encrypt0)

COSE_Encrypt0 = [
    Headers,
    ciphertext : bstr / nil,
]

Enc_structure = [
    context : "Encrypt" / "Encrypt0" / "Enc_Recipient" /
        "Mac_Recipient" / "Rec_Recipient",
    protected : empty_or_serialized_map,
    external_aad : bstr
]

COSE_Mac_Tagged = #6.97(COSE_Mac)

COSE_Mac = [
   Headers,
   payload : bstr / nil,
   tag : bstr,
   recipients :[+COSE_recipient]
]

COSE_Mac0_Tagged = #6.17(COSE_Mac0)

COSE_Mac0 = [
   Headers,
   payload : bstr / nil,
   tag : bstr,
]

MAC_structure = [
     context : "MAC" / "MAC0",
     protected : empty_or_serialized_map,
     external_aad : bstr,
     payload : bstr
]

COSE_Key = {
    1 => tstr / int,          ; kty
    ? 2 => bstr,              ; kid
    ? 3 => tstr / int,        ; alg
    ? 4 => [+ (tstr / int) ], ; key_ops
    ? 5 => bstr,              ; Base IV
    * label => values
}

COSE_KeySet = [+COSE_Key]

PartyInfo = (
    identity : bstr / nil,
    nonce : bstr / int / nil,
    other : bstr / nil,
)

COSE_KDF_Context = [
    AlgorithmID : int / tstr,
    PartyUInfo : [ PartyInfo ],
    PartyVInfo : [ PartyInfo ],
    SuppPubInfo : [
        keyDataLength : uint,
        protected : empty_or_serialized_map,
        ? other : bstr
    ],
    ? SuppPrivInfo : bstr
]
COSE_X509 = bstr / [ 2*certs: bstr ]
COSE_CertHash = [ hashAlg: (int / tstr), hashValue: bstr ]
; This relies on the defintions of BPv7 "bpv7.cddl"

; Generic structure of block-type-specific data for BIB and BCB
ext-data-asb = $ext-data-asb .within ext-data-asb-structure
ext-data-asb-structure = [
  targets: [1* target-block-num],
  context-id: int,
  asb-flags,
  security-source: eid,
  ? parameters: asb-id-value-list, ; if sec-params-present is set
  target-results: [1* asb-id-value-list]
]
target-block-num = uint
asb-flags = uint .bits asb-flag-bits
asb-flag-bits = &(
  sec-params-present: 0
)

; Alternatives can be added to the sockets for each context ID
asb-id-value-list = [1* asb-id-value-pair]
; Interpretation of the pair depends on the context-id and whether
; it is a parameter or a result.
asb-id-value-pair = [
  id: uint,
  value: any
]

; Provide BPv7 extension block types, they both really embed "ext-data-asb" as
; a cbor sequence.
; Block Integrity Block
$extension-block /= extension-block-use<11, bstr .cborseq any>
; Block Confidentiality Block
$extension-block /= extension-block-use<12, bstr .cborseq any>

; Specialization of $ext-data-asb for a security context
; The ParamPair and ResultPair should be sockets for specializing those types.
bpsec-context-use<ContextId, ParamPair, ResultPair> = [
  targets: [
    1* target-block-num
  ],
  context-id: ContextId,
  asb-flags,
  ? security-source: eid,
  ? parameters: [
    1* ParamPair .within asb-id-value-pair
  ],
  target-results: [
    1* [
      1* ResultPair .within asb-id-value-pair
    ]
  ]
]
bpv7_start = bundle / #6.55799(bundle)

; Times before 2000 are invalid
dtn-time = uint

; CRC enumerated type
crc-type = &(
  crc-none: 0,
  crc-16bit: 1,
  crc-32bit: 2
)
; Either 16-bit or 32-bit
crc-value = (bstr .size 2) / (bstr .size 4)

creation-timestamp = [
  dtn-time, ; absolute time of creation
  sequence: uint ; sequence within the time
]

eid = $eid .within eid-structure
eid-structure = [
  uri-code: uint,
  SSP: any
]
$eid /= [
  uri-code: 1,
  SSP: (tstr / 0)
]
$eid /= [
  uri-code: 2,
  SSP: [
    nodenum: uint,
    servicenum: uint
  ]
]

; The root bundle array
bundle = [primary-block, *extension-block, payload-block]

primary-block = [
  version: 7,
  bundle-control-flags,
  crc-type,
  destination: eid,
  source-node: eid,
  report-to: eid,
  creation-timestamp,
  lifetime: uint,
  ? (
    fragment-offset: uint,
    total-application-data-length: uint
  ),
  ? crc-value,
]
bundle-control-flags = uint .bits bundleflagbits
bundleflagbits = &(
  reserved: 21,
  reserved: 20,
  reserved: 19,
  bundle-deletion-status-reports-are-requested: 18,
  bundle-delivery-status-reports-are-requested: 17,
  bundle-forwarding-status-reports-are-requested: 16,
  reserved: 15,
  bundle-reception-status-reports-are-requested: 14,
  reserved: 13,
  reserved: 12,
  reserved: 11,
  reserved: 10,
  reserved: 9,
  reserved: 8,
  reserved: 7,
  status-time-is-requested-in-all-status-reports: 6,
  user-application-acknowledgement-is-requested: 5,
  reserved: 4,
  reserved: 3,
  bundle-must-not-be-fragmented: 2,
  payload-is-an-administrative-record: 1,
  bundle-is-a-fragment: 0
)

; Abstract shared structure of all non-primary blocks
canonical-block-structure = [
  block-type-code: uint,
  block-number: uint,
  block-control-flags,
  crc-type,
  ; Each block type defines the content within the bytestring
  block-type-specific-data,
  ? crc-value
]
block-control-flags = uint .bits blockflagbits
blockflagbits = &(
  reserved: 7,
  reserved: 6,
  reserved: 5,
  block-must-be-removed-from-bundle-if-it-cannot-be-processed: 4,
  reserved: 3,
  bundle-must-be-deleted-if-block-cannot-be-processed: 2,
  status-report-must-be-transmitted-if-block-cannot-be-processed: 1,
  block-must-be-replicated-in-every-fragment: 0
)
block-type-specific-data = bstr / #6.24(bstr)
; Actual CBOR data embedded in a bytestring, with optional tag to indicate so.
; Additional plain bstr allows ciphertext data.
embedded-cbor<Item> = (bstr .cbor Item) / #6.24(bstr .cbor Item) / bstr

; Extension block type, which does not specialize other than the code/number
extension-block = $extension-block .within canonical-block-structure
; Generic shared structure of all non-primary blocks
extension-block-use<CodeValue, BlockData> = [
  block-type-code: CodeValue,
  block-number: (uint .gt 1),
  block-control-flags,
  crc-type,
  BlockData,
  ? crc-value
]

; Payload block type
payload-block = payload-block-structure .within canonical-block-structure
payload-block-structure = [
  block-type-code: 1,
  block-number: 1,
  block-control-flags,
  crc-type,
  $payload-block-data,
  ? crc-value
]

; Arbitrary payload data, including non-CBOR bytestring
$payload-block-data /= block-type-specific-data


; Administrative record as a payload data specialization
$payload-block-data /= embedded-cbor<admin-record>
admin-record = $admin-record .within admin-record-structure
admin-record-structure = [
  record-type-code: uint,
  record-content: any
]
; Only one defined record type
$admin-record /= [1, status-record-content]
status-record-content = [
  bundle-status-information,
  status-report-reason-code: uint,
  source-node-eid: eid,
  subject-creation-timestamp: creation-timestamp,
  ? (
    subject-payload-offset: uint,
    subject-payload-length: uint
  )
]
bundle-status-information = [
  reporting-node-received-bundle: status-info-content,
  reporting-node-forwarded-bundle: status-info-content,
  reporting-node-delivered-bundle: status-info-content,
  reporting-node-deleted-bundle: status-info-content
]
status-info-content = [
  status-indicator: bool,
  ? timestamp: dtn-time
]


; Previous Node extension block
$extension-block /=
  extension-block-use<6, embedded-cbor<ext-data-previous-node>>
ext-data-previous-node = eid

; Bundle Age extension block
$extension-block /= 
  extension-block-use<7, embedded-cbor<ext-data-bundle-age>>
ext-data-bundle-age = uint

; Hop Count extension block
$extension-block /=
  extension-block-use<10, embedded-cbor<ext-data-hop-count>>
ext-data-hop-count = [
  hop-limit: uint,
  hop-count: uint
]
